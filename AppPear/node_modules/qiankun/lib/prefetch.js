"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prefetchApps = prefetchApps;

var _isFunction2 = _interopRequireDefault(require("lodash/isFunction"));

var _tslib = require("tslib");

var _importHtmlEntry = require("import-html-entry");

var _singleSpa = require("single-spa");

/**
 * @author Kuitos
 * @since 2019-02-26
 */
// RIC and shim for browsers setTimeout() without it
var requestIdleCallback = window.requestIdleCallback || function requestIdleCallback(cb) {
  var start = Date.now();
  return setTimeout(function () {
    cb({
      didTimeout: false,
      timeRemaining: function timeRemaining() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
}; // https://stackoverflow.com/questions/3514784/what-is-the-best-way-to-detect-a-mobile-device


var isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
var isSlowNetwork = navigator.connection ? navigator.connection.saveData || /(2|3)g/.test(navigator.connection.effectiveType) : false;
/**
 * prefetch assets, do nothing while in mobile network
 * @param entry
 * @param opts
 */

function prefetch(entry, opts) {
  var _this = this;

  if (isMobile || isSlowNetwork) {
    // Don't prefetch if an mobile device or in a slow network.
    return;
  }

  requestIdleCallback(function () {
    return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {
      var _a, getExternalScripts, getExternalStyleSheets;

      return (0, _tslib.__generator)(this, function (_b) {
        switch (_b.label) {
          case 0:
            return [4
            /*yield*/
            , (0, _importHtmlEntry.importEntry)(entry, opts)];

          case 1:
            _a = _b.sent(), getExternalScripts = _a.getExternalScripts, getExternalStyleSheets = _a.getExternalStyleSheets;
            requestIdleCallback(getExternalStyleSheets);
            requestIdleCallback(getExternalScripts);
            return [2
            /*return*/
            ];
        }
      });
    });
  });
}

function prefetchAfterFirstMounted(apps, opts) {
  window.addEventListener('single-spa:first-mount', function listener() {
    var mountedApps = (0, _singleSpa.getMountedApps)();
    var notMountedApps = apps.filter(function (app) {
      return mountedApps.indexOf(app.name) === -1;
    });

    if (process.env.NODE_ENV === 'development') {
      console.log("[qiankun] prefetch starting after " + mountedApps + " mounted...", notMountedApps);
    }

    notMountedApps.forEach(function (_a) {
      var entry = _a.entry;
      return prefetch(entry, opts);
    });
    window.removeEventListener('single-spa:first-mount', listener);
  });
}

function prefetchImmediately(apps, opts) {
  if (process.env.NODE_ENV === 'development') {
    console.log('[qiankun] prefetch starting for apps...', apps);
  }

  apps.forEach(function (_a) {
    var entry = _a.entry;
    return prefetch(entry, opts);
  });
}

function prefetchApps(apps, prefetchAction, importEntryOpts) {
  var _this = this;

  var appsName2Apps = function appsName2Apps(names) {
    return apps.filter(function (app) {
      return names.includes(app.name);
    });
  };

  if (Array.isArray(prefetchAction)) {
    prefetchAfterFirstMounted(appsName2Apps(prefetchAction), importEntryOpts);
  } else if ((0, _isFunction2.default)(prefetchAction)) {
    (function () {
      return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {
        var _a, _b, criticalAppNames, _c, minorAppsName;

        return (0, _tslib.__generator)(this, function (_d) {
          switch (_d.label) {
            case 0:
              return [4
              /*yield*/
              , prefetchAction(apps)];

            case 1:
              _a = _d.sent(), _b = _a.criticalAppNames, criticalAppNames = _b === void 0 ? [] : _b, _c = _a.minorAppsName, minorAppsName = _c === void 0 ? [] : _c;
              prefetchImmediately(appsName2Apps(criticalAppNames), importEntryOpts);
              prefetchAfterFirstMounted(appsName2Apps(minorAppsName), importEntryOpts);
              return [2
              /*return*/
              ];
          }
        });
      });
    })();
  } else {
    switch (prefetchAction) {
      case true:
        prefetchAfterFirstMounted(apps, importEntryOpts);
        break;

      case 'all':
        prefetchImmediately(apps, importEntryOpts);
        break;

      default:
        break;
    }
  }
}